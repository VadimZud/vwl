#ifndef _VWLDEF_H
#define _VWLDEF_H 1

#include "vwldef.h"

/*Объект-ручка*/
typedef _vwl_handle vwl_handle;

/*Открывает file и возвращает связанный с ним vwl-обработчик.
В случае ошибки возвращает NULL.*/
vwl_handle *vwl_openfile(const char *file);

/*Уничтожает обработчик handle и закрывает связанный с ним файл.
В случает успеха возвращает 0, в случае ошибки возвращает 1.*/
int vwl_closefile(vwl_handle *handle);

/*Читает аудиоданные с начала файла, связанного с обработчиком handle.
Если buf указывает на NULL, то библиотека постарается самостоятельно выделить буфер, достаточный для размещения всех данных из файла. Указатель на полученный буфер будет записан по адресу buf.
Иначе, считается, что по адресу buf передан указатель на буфер, в который следует читать данные. При этом число читаемых сэмплов не превышает значения, переданного по адресу nmemb.
В любом случае, число прочитанных сэмплов будет записано по адресу nmemb.
При работе с библиотекой чтение данных обязательно должно начинаться с этой функции.
В случает успеха возвращает 0, в случае ошибки возвращает 1.*/
int vwl_firstbuf(vwl_handle *handle, void **buf, unsigned int *nmemb);

/*Эквивалентна firstbuf(), но читает данные, начиная с позиции, на которой остановился предыдущий вызов vwl_firstbuf() или vwl_nextbuf().
Перед вызовом этой функции, должен быть выполнен хотя бы один вызов функции vwl_firstbuf().*/
int vwl_nextbuf(vwl_handle *handle, void **buf, unsigned int *nmemb);

/*Возвращает строку, описывающую состояние ошибки обработчика handle.*/
char *vwl_strerror(vwl_handle *handle);

/*Печатает на стандартный вывод ошибок сообщение, описывающую состояние ошибки обработчика handle. 
Первой (если s != NULL) печатается строка s со следующим за ней двоеточием, после чего печатается сам текст сообщения.*/
void vwl_perror(vwl_handle *handle, const char *s);

/*Связаный с обработчиком файл*/
FILE *vwl_getfile(vwl_handle *handle);

/*Число каналов*/
unsigned int vwl_getnchans(vwl_handle *handle);

/*Частота дискретизации.*/
unsigned int vwl_getrate(vwl_handle *handle);

/*Фактический формат сэмплов в файле (форматы сэмплов определены в vwldef.h).*/
int vwl_getfilefmt(vwl_handle *handle);

/*Выходной формат сэмплов, в котором они предоставляются вызывающему модулю.*/
int vwl_getusrfmt(vwl_handle *handle);
int vwl_setusrfmt(vwl_handle *handle, int fmt);

/*Размер аудиоданных в сэмплах.*/
unsigned int vwl_getnsamp(vwl_handle *handle);

/****Обработка ошибок****/

/*Код состояния ошибки (коды ошибок определены в vwldef.h).*/
int vwl_geterrno(vwl_handle *handle);

/*Возвращает строку, описывающую состояние ошибки обработчика handle.*/
char *vwl_strerror(vwl_handle *handle);

/*Печатает на стандартный вывод ошибок сообщение, описывающую состояние ошибки обработчика handle. 
Первой (если s != NULL) печатается строка s со следующим за ней двоеточием, после чего печатается сам текст сообщения.*/
void vwl_perror(vwl_handle *handle, const char *s);

/****Работа с сэмплами****/

/*Возвращает 1, если code определён как формат сэмпла, и 0 в противном случае*/
int vwl_issamp(code);

/*Возвращает размер сэмпла с кодом формата code. Если code не определён как формат сэмпла, возвращает 0*/
size_t vwl_sampsize(code);

/*Возвращает 1, если сэмпл с кодом формата code имеет little-endian порядок байт, и 0 в противном случае. 
Если code не определён как формат сэмпла, возвращает 0*/
int vwl_isle(code);

/*Возвращает 1, если сэмпл с кодом формата code знаковый, и 0 в противном случае. 
Если code не определён как формат сэмпла, возвращает 0*/
int vwl_issigned(code);

/*Конвертирует сэмпл, находящийся по адресу srcsamp из формата srcfmt в формат destfmt. 
Результат записывается по адресу destsamp. 
В случае успеха возвращает 0. В случае ошибки возвращает 1. 
Примечание: при конвертировании между форматами с различным размером, значение сэмпла "масштабируется" к его новому диапазону, например, значение 128 в беззнаковом 8-и битном сэмпле превратится в 32768 в беззнаковом 16-и битном.*/
int vwl_convsamp(void *srcsamp, int srcfmt, void *destsamp, int destfmt);

#endif
